<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Match Championship - Professional Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap');

        :root {
            --bg-color: #0f0f17;
            --container-bg: #1a1a27;
            --card-back-color: linear-gradient(145deg, #2a2a3e, #232337);
            --card-front-color: #f8f9fa;
            --text-color: #e2e8f0;
            --accent-color: #00d4ff;
            --accent-glow: rgba(0, 212, 255, 0.3);
            --success-color: #22d3ee;
            --warning-color: #fbbf24;
            --error-color: #ef4444;
            --gold-color: #ffd700;
            --silver-color: #c0c0c0;
            --bronze-color: #cd7f32;
            --match-glow: #22d3ee;
            --border-radius: 16px;
            --box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            --transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            --flip-duration: 0.7s;
            --card-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--bg-color) 0%, #1a1a2e 100%);
            color: var(--text-color);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: auto;
            position: relative;
           
        }

        /* Animated background particles */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 20% 80%, rgba(0, 212, 255, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 80% 20%, rgba(34, 211, 238, 0.1) 0%, transparent 50%);
            z-index: -1;
            animation: particleFloat 10s ease-in-out infinite alternate;
        }

        @keyframes particleFloat {
            0% { opacity: 0.3; transform: translateY(0px); }
            100% { opacity: 0.6; transform: translateY(-20px); }
        }

        .game-container {
            background: var(--container-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 40px;
            max-width: 1300px;
            width: 100%;
            text-align: center;
            position: relative;
            max-height: 95vh;
            overflow-y: auto;
            border: 1px solid rgba(0, 212, 255, 0.2);
        }

        .nav-header {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .nav-btn {
            background: linear-gradient(135deg, var(--accent-color), #0ea5e9);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }

        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 212, 255, 0.5);
        }

        h1 {
            color: var(--accent-color);
            font-size: 2.8rem;
            font-weight: 800;
            margin-bottom: 30px;
            text-shadow: 0 4px 20px var(--accent-glow);
            animation: titleGlow 3s ease-in-out infinite alternate;
            background: linear-gradient(135deg, var(--accent-color), #22d3ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        @keyframes titleGlow {
            from { filter: drop-shadow(0 0 10px rgba(0, 212, 255, 0.3)); }
            to { filter: drop-shadow(0 0 20px rgba(0, 212, 255, 0.6)); }
        }

        .screen {
            display: none;
        }

        .screen.active {
            display: block;
            animation: screenSlide 0.6s ease-out;
        }

        @keyframes screenSlide {
            from { opacity: 0; transform: translateX(30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* Score System */
        .score-board {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .score-item {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(34, 211, 238, 0.1));
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: var(--border-radius);
            padding: 15px 20px;
            text-align: center;
            min-width: 120px;
        }

        .score-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent-color);
            text-shadow: 0 2px 10px var(--accent-glow);
        }

        .score-label {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Streak System */
        .streak-indicator {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: linear-gradient(135deg, var(--warning-color), #f59e0b);
            color: #000;
            padding: 10px 15px;
            border-radius: 50px;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(251, 191, 36, 0.4);
            opacity: 0;
            transition: var(--transition);
        }

        .streak-indicator.show {
            opacity: 1;
            animation: streakPulse 0.6s ease-out;
        }

        @keyframes streakPulse {
            0% { transform: translateY(-50%) scale(0.8); }
            50% { transform: translateY(-50%) scale(1.2); }
            100% { transform: translateY(-50%) scale(1); }
        }

        /* Progress Enhancement */
        .progress-container {
            margin: 25px 0;
            text-align: center;
        }

        .progress-bar {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50px;
            height: 12px;
            overflow: hidden;
            margin: 15px 0;
            position: relative;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .progress-fill {
            background: linear-gradient(90deg, var(--accent-color), var(--success-color));
            height: 100%;
            border-radius: 50px;
            transition: width 0.8s ease;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.6);
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: progressShine 2s infinite;
        }

        @keyframes progressShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-text {
            font-size: 16px;
            color: var(--accent-color);
            font-weight: 600;
            text-shadow: 0 2px 10px var(--accent-glow);
        }

        /* Setup Screen Styles */
        .setup-screen {
            max-width: 600px;
            margin: 0 auto;
        }

        .setup-group {
            margin-bottom: 25px;
            text-align: left;
        }

        .setup-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-color);
        }

        .setup-group select,
        .setup-group input {
            width: 100%;
            padding: 14px 18px;
            border: 2px solid rgba(0, 212, 255, 0.3);
            border-radius: var(--border-radius);
            background: rgba(0, 0, 0, 0.3);
            color: var(--text-color);
            font-size: 16px;
            transition: var(--transition);
        }

        .setup-group select:focus,
        .setup-group input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px var(--accent-glow);
        }

        .player-name-inputs {
            display: grid;
            gap: 15px;
            margin-top: 20px;
        }

        .player-name-row {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .player-indicator {
            background: linear-gradient(135deg, var(--accent-color), var(--success-color));
            color: white;
            padding: 12px 16px;
            border-radius: 50%;
            font-weight: 700;
            min-width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px var(--accent-glow);
        }

        button {
            background: linear-gradient(135deg, var(--accent-color), #0ea5e9);
            color: white;
            border: none;
            padding: 16px 32px;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: var(--transition);
            margin: 10px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0, 212, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 30px rgba(0, 212, 255, 0.5);
        }

        button:active {
            transform: translateY(-1px);
        }

        button.secondary {
            background: linear-gradient(135deg, var(--success-color), #06b6d4);
        }

        button.danger {
            background: linear-gradient(135deg, var(--error-color), #dc2626);
        }

        button.warning {
            background: linear-gradient(135deg, var(--warning-color), #f59e0b);
        }

        /* Enhanced Player Display */
        .player-info-bar {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .player-box {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(34, 211, 238, 0.1));
            border: 2px solid transparent;
            border-radius: var(--border-radius);
            padding: 20px;
            min-width: 200px;
            transition: var(--transition);
            position: relative;
            backdrop-filter: blur(10px);
        }

        .player-box.active {
            border-color: var(--accent-color);
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(34, 211, 238, 0.2));
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.4);
            animation: activePlayerPulse 2s infinite;
        }

        @keyframes activePlayerPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 212, 255, 0.4); }
            50% { box-shadow: 0 0 40px rgba(0, 212, 255, 0.8); }
        }

        .player-name {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 10px;
            color: var(--accent-color);
        }

        .player-stats {
            font-size: 14px;
            opacity: 0.9;
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
        }

        /* Professional Card System */
        .game-board-area {
            margin: 30px 0;
            position: relative;
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(85px, 1fr));
            gap: 15px;
            justify-content: center;
            max-width: 900px;
            margin: 0 auto;
            max-height: 60vh;
            overflow-y: auto;
            padding: 10px;
        }

        .card-container {
            perspective: 1200px;
            aspect-ratio: 1;
            min-height: 110px;
        }

        .card {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: var(--border-radius);
            cursor: pointer;
            transform-style: preserve-3d;
            transition: transform var(--flip-duration) cubic-bezier(0.4, 0, 0.2, 1);
            user-select: none;
        }

        .card:hover:not(.flipped):not(.matched) {
            transform: scale(1.05) rotateY(-8deg);
            box-shadow: 0 15px 40px rgba(0, 212, 255, 0.3);
        }

        .card.flipped {
            transform: rotateY(180deg);
        }

        .card.matched {
            transform: rotateY(180deg);
            /* Keep matched cards fully visible - no blur or opacity changes */
            box-shadow: 0 0 25px var(--match-glow);
            animation: matchSuccess 1s ease-out;
        }

        @keyframes matchSuccess {
            0% { box-shadow: 0 0 0 rgba(34, 211, 238, 0); }
            50% { box-shadow: 0 0 40px rgba(34, 211, 238, 0.8); }
            100% { box-shadow: 0 0 25px var(--match-glow); }
        }

        .card.shake {
            animation: cardShake 0.6s ease-in-out;
        }

        @keyframes cardShake {
            0%, 100% { transform: translateX(0) rotateY(0deg); }
            25% { transform: translateX(-8px) rotateY(-5deg); }
            75% { transform: translateX(8px) rotateY(5deg); }
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: var(--border-radius);
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            padding: 12px;
            border: 2px solid transparent;
            box-shadow: var(--card-shadow);
        }

        .card-back {
            background: var(--card-back-color);
            border: 2px solid rgba(0, 212, 255, 0.3);
            /* Removed ? mark - plain elegant design */
            background-image: linear-gradient(45deg, rgba(255,255,255,0.1) 25%, transparent 25%),
                              linear-gradient(-45deg, rgba(255,255,255,0.1) 25%, transparent 25%),
                              linear-gradient(45deg, transparent 75%, rgba(255,255,255,0.1) 75%),
                              linear-gradient(-45deg, transparent 75%, rgba(255,255,255,0.1) 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        .card-front {
            background: linear-gradient(135deg, var(--card-front-color), #f1f5f9);
            color: #1e293b;
            transform: rotateY(180deg);
            border: 2px solid var(--accent-color);
        }

        .card-emoji {
            font-size: 2.8rem;
            margin-bottom: 8px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.2));
        }

        .card-name {
            font-size: 0.95rem;
            text-align: center;
            line-height: 1.2;
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
        }

        /* Hint System */
        .hint-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, var(--warning-color), #f59e0b);
            color: #000;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: 0 4px 15px rgba(251, 191, 36, 0.3);
        }

        .hint-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(251, 191, 36, 0.5);
        }

        .hint-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Achievement Notifications */
        .achievement-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, var(--gold-color), #fbbf24);
            color: #000;
            padding: 15px 20px;
            border-radius: var(--border-radius);
            font-weight: 700;
            z-index: 1000;
            transform: translateX(400px);
            transition: var(--transition);
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.4);
        }

        .achievement-notification.show {
            transform: translateX(0);
        }

        /* Enhanced Timer */
        .timer-display {
            font-size: 32px;
            font-weight: 800;
            color: var(--accent-color);
            margin: 20px 0;
            text-shadow: 0 4px 20px var(--accent-glow);
            font-family: 'Courier New', monospace;
        }

        .status-display {
            font-size: 20px;
            margin: 20px 0;
            min-height: 30px;
            font-weight: 600;
            color: var(--accent-color);
            text-shadow: 0 2px 10px var(--accent-glow);
        }

        .game-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin: 30px 0;
        }

        /* Premium Results Screen */
        .results-container {
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
        }

        .winner-announcement {
            font-size: 3rem;
            font-weight: 800;
            margin: 30px 0;
            background: linear-gradient(135deg, var(--gold-color), var(--warning-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 4px 20px rgba(255, 215, 0, 0.5);
            animation: winnerBounce 1.5s ease-in-out;
        }

        @keyframes winnerBounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-30px); }
            60% { transform: translateY(-15px); }
        }

        .final-results {
            display: grid;
            gap: 20px;
            margin: 30px 0;
        }

        .player-final-result {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(34, 211, 238, 0.1));
            border-radius: var(--border-radius);
            padding: 25px;
            border: 2px solid transparent;
            transition: var(--transition);
            backdrop-filter: blur(10px);
        }

        .player-final-result.winner-result {
            border-color: var(--gold-color);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(251, 191, 36, 0.2));
            animation: winnerResultGlow 2s ease-in-out infinite alternate;
        }

        @keyframes winnerResultGlow {
            from { box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }
            to { box-shadow: 0 0 40px rgba(255, 215, 0, 0.6); }
        }

        .final-player-name {
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 15px;
            color: var(--accent-color);
        }

        .final-stats {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
        }

        .final-stat {
            text-align: center;
        }

        .final-stat-value {
            font-size: 26px;
            font-weight: 700;
            color: var(--accent-color);
            text-shadow: 0 2px 10px var(--accent-glow);
        }

        .final-stat-label {
            font-size: 14px;
            opacity: 0.8;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Enhanced Leaderboard */
        .leaderboard-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .leaderboard-stats-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
            margin: 20px 0 30px 0;
        }

        .stats-card {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(34, 211, 238, 0.1));
            border-radius: var(--border-radius);
            padding: 25px;
            text-align: center;
            border: 2px solid transparent;
            transition: var(--transition);
            backdrop-filter: blur(10px);
        }

        .stats-card:hover {
            border-color: var(--accent-color);
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.15), rgba(34, 211, 238, 0.15));
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 212, 255, 0.2);
        }

        .stats-card-value {
            font-size: 2.2rem;
            font-weight: 800;
            color: var(--accent-color);
            margin-bottom: 8px;
            text-shadow: 0 2px 10px var(--accent-glow);
        }

        .stats-card-label {
            font-size: 14px;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .leaderboard-table-container {
            background: rgba(0, 0, 0, 0.2);
            border-radius: var(--border-radius);
            overflow-x: auto;
            margin: 20px 0;
            border: 1px solid rgba(0, 212, 255, 0.2);
        }

        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 1000px;
        }

        .leaderboard-table th,
        .leaderboard-table td {
            padding: 15px 18px;
            text-align: left;
            border-bottom: 1px solid rgba(0, 212, 255, 0.1);
            white-space: nowrap;
        }

        .leaderboard-table th {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(34, 211, 238, 0.2));
            font-weight: 700;
            color: var(--accent-color);
            position: sticky;
            top: 0;
            z-index: 10;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .leaderboard-table tbody tr:hover {
            background: rgba(0, 212, 255, 0.05);
            transform: scale(1.01);
        }

        .rank-position {
            font-weight: 700;
            background: var(--accent-color);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            display: inline-block;
            min-width: 35px;
            text-align: center;
        }

        .rank-1 { 
            background: linear-gradient(135deg, var(--gold-color), #fbbf24);
            color: #000;
            animation: goldShimmer 2s ease-in-out infinite alternate;
        }

        @keyframes goldShimmer {
            from { box-shadow: 0 0 15px rgba(255, 215, 0, 0.5); }
            to { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); }
        }

        .rank-2 { 
            background: linear-gradient(135deg, var(--silver-color), #9ca3af);
            color: #000; 
        }

        .rank-3 { 
            background: linear-gradient(135deg, var(--bronze-color), #a16207);
            color: white; 
        }

        .player-name-cell {
            font-weight: 700;
            color: var(--accent-color);
        }

        .win-rate-high { color: var(--success-color); font-weight: 700; }
        .win-rate-medium { color: var(--warning-color); font-weight: 700; }
        .win-rate-low { color: var(--error-color); font-weight: 700; }

        .empty-leaderboard {
            text-align: center;
            padding: 80px 20px;
            color: var(--text-color);
            opacity: 0.6;
        }

        .hidden {
            display: none !important;
        }

        /* Celebration Effects */
        .celebration {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .confetti {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--accent-color);
            animation: confetti-fall 4s linear infinite;
        }

        @keyframes confetti-fall {
            0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .game-container {
                padding: 20px;
                margin: 10px;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            .nav-header {
                position: static;
                margin-bottom: 20px;
                justify-content: center;
            }
            
            .score-board {
                gap: 15px;
            }
            
            .player-info-bar {
                gap: 10px;
            }
            
            .player-box {
                min-width: 170px;
                padding: 15px;
            }
            
            .card-container {
                min-height: 85px;
            }
            
            .card-emoji {
                font-size: 2.2rem;
            }
            
            .card-name {
                font-size: 0.8rem;
            }
            

            .leaderboard-stats-summary {
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
            }

            .leaderboard-table th,
            .leaderboard-table td {
                padding: 10px 12px;
                font-size: 14px;
            }
        }

        /* Scrollbar styling */
        .game-grid::-webkit-scrollbar,
        .leaderboard-table-container::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        .game-grid::-webkit-scrollbar-track,
        .leaderboard-table-container::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        .game-grid::-webkit-scrollbar-thumb,
        .leaderboard-table-container::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, var(--accent-color), var(--success-color));
            border-radius: 5px;
        }

        .game-grid::-webkit-scrollbar-thumb:hover,
        .leaderboard-table-container::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #0ea5e9, #06b6d4);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="nav-header">
            <button class="nav-btn" onclick="showLeaderboard()">üèÜ Leaderboard</button>
        </div>

        <button class="hint-button" id="hint-btn" onclick="useHint()" style="display: none">üí° Hint (3)</button>

        <h1>Memory Match Championship</h1>

        <!-- Setup Screen -->
        <div id="setup-screen" class="screen active">
            <div class="setup-screen">
                <div class="setup-group">
                    <label for="language-select">Select Language:</label>
                    <select id="language-select">
                        <option value="en-US">English</option>
                        <option value="gu-IN">‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä</option>
                    </select>
                </div>

                <div class="setup-group">
                    <label for="num-players">Number of Players:</label>
                    <select id="num-players" onchange="generatePlayerInputs()">
                        <option value="2">2 Players</option>
                        <option value="3">3 Players</option>
                        <option value="4">4 Players</option>
                        <option value="5">5 Players</option>
                    </select>
                </div>

                <div class="setup-group">
                    <label for="board-size">Number of Cards (4-200, even numbers only):</label>
                    <input type="number" id="board-size" value="16" min="4" max="200" step="2">
                </div>

                <div class="setup-group">
                    <label>Player Names:</label>
                    <div class="player-name-inputs" id="player-name-inputs">
                        <!-- Player name inputs will be generated dynamically -->
                    </div>
                </div>

                <button onclick="startGame()">üéÆ Start Championship</button>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="screen">
            <div class="score-board" id="score-board">
                <div class="score-item">
                    <div class="score-value" id="current-score">0</div>
                    <div class="score-label">Score</div>
                </div>
                <div class="score-item">
                    <div class="score-value" id="current-streak">0</div>
                    <div class="score-label">Streak</div>
                </div>
                <div class="score-item">
                    <div class="score-value" id="bonus-points">0</div>
                    <div class="score-label">Bonus</div>
                </div>
            </div>

            <div class="streak-indicator" id="streak-indicator">üî• Streak x2!</div>

            <div class="player-info-bar" id="player-info-bar">
                <!-- Player information will be displayed here -->
            </div>

            <div class="timer-display">
                ‚è±Ô∏è <span id="game-timer">00:00</span>
            </div>

            <div class="progress-container">
                <div class="progress-text" id="progress-text">0 of 0 pairs matched</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
            </div>

            <div class="status-display" id="status-display">
                Click cards to find matching pairs!
            </div>

            <div class="game-board-area">
                <div class="game-grid" id="game-grid">
                    <!-- Game cards will be generated here -->
                </div>
            </div>

            <div class="game-controls">
                <button id="sound-btn" onclick="toggleSound()">üîä Sound On</button>
                <button class="warning" onclick="pauseGame()">‚è∏Ô∏è Pause</button>
                <button class="danger" onclick="quitGame()">üè† Main Menu</button>
            </div>
        </div>

        <!-- Results Screen -->
        <div id="results-screen" class="screen">
            <div class="results-container">
                <div class="winner-announcement" id="winner-text">
                    üéâ Championship Complete! üéâ
                </div>

                <div class="final-results" id="final-results">
                    <!-- Final results will be displayed here -->
                </div>

                <div class="game-controls">
                    <button class="secondary" onclick="playAgain()">üîÑ Play Again</button>
                    <button onclick="restartGame()">üè† New Championship</button>
                    <button class="warning" onclick="showLeaderboard()">üèÜ View Leaderboard</button>
                </div>
            </div>
        </div>

        <!-- Enhanced Leaderboard Screen -->
        <div id="leaderboard-screen" class="screen">
            <div class="leaderboard-container">
                <h2 style="color: var(--accent-color); margin-bottom: 30px; font-size: 2.2rem; font-weight: 700;">üèÜ Championship Leaderboard</h2>
                
                <!-- Statistics Summary -->
                <div class="leaderboard-stats-summary" id="leaderboard-stats-summary">
                    <!-- Stats cards will be generated here -->
                </div>

                <div class="game-controls">
                    <button onclick="clearLeaderboard()" class="danger">üóëÔ∏è Clear Records</button>
                    <button onclick="backFromLeaderboard()">üîô Back</button>
                </div>

                <!-- Detailed Leaderboard Table -->
                <div class="leaderboard-table-container">
                    <table class="leaderboard-table" id="leaderboard-table">
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Player Name</th>
                                <th>Score</th>
                                <th>Games</th>
                                <th>Won</th>
                                <th>Lost</th>
                                <th>Win Rate</th>
                                <th>Pairs</th>
                                <th>Avg/Game</th>
                                <th>Best Time</th>
                                <th>Total Time</th>
                                <th>Avg Time</th>
                                <th>Last Played</th>
                            </tr>
                        </thead>
                        <tbody id="leaderboard-body">
                            <!-- Leaderboard entries will be populated here -->
                        </tbody>
                    </table>
                </div>

                <div id="empty-leaderboard" class="empty-leaderboard hidden">
                    <h3>üìä No Championship Records Found</h3>
                    <p>Play some games to see detailed player statistics and rankings here!</p>
                </div>
            </div>
        </div>

        <!-- Achievement Notification -->
        <div id="achievement-notification" class="achievement-notification">
            <span id="achievement-text">üèÜ Achievement Unlocked!</span>
        </div>

        <!-- Celebration Effect Container -->
        <div id="celebration" class="celebration hidden"></div>
    </div>

    <script>
        // Object data from your original file
        const objectDataEnglish = [
            { name: "Apple", emoji: "üçé" }, { name: "Banana", emoji: "üçå" },
            { name: "Orange", emoji: "üçä" }, { name: "Grape", emoji: "üçá" },
            { name: "Watermelon", emoji: "üçâ" }, { name: "Strawberry", emoji: "üçì" },
            { name: "Lemon", emoji: "üçã" }, { name: "Mango", emoji: "ü•≠" },
            { name: "Cat", emoji: "üê±" }, { name: "Dog", emoji: "üê∂" },
            { name: "Lion", emoji: "ü¶Å" }, { name: "Tiger", emoji: "üêÖ" },
            { name: "Elephant", emoji: "üêò" }, { name: "Rabbit", emoji: "üê∞" },
            { name: "Bear", emoji: "üêª" }, { name: "Fox", emoji: "ü¶ä" },
            { name: "Tree", emoji: "üå≥" }, { name: "Flower", emoji: "üå∏" },
            { name: "Sun", emoji: "‚òÄÔ∏è" }, { name: "Moon", emoji: "üåô" },
            { name: "Star", emoji: "‚≠ê" }, { name: "Cloud", emoji: "‚òÅÔ∏è" },
            { name: "Rainbow", emoji: "üåà" }, { name: "Mountain", emoji: "‚õ∞Ô∏è" },
            { name: "House", emoji: "üè†" }, { name: "Car", emoji: "üöó" },
            { name: "Plane", emoji: "‚úàÔ∏è" }, { name: "Ship", emoji: "üö¢" },
            { name: "Book", emoji: "üìö" }, { name: "Pen", emoji: "‚úèÔ∏è" },
            { name: "Phone", emoji: "üì±" }, { name: "Computer", emoji: "üíª" },
            { name: "Watch", emoji: "‚åö" }, { name: "Camera", emoji: "üì∑" },
            { name: "Ball", emoji: "‚öΩ" }, { name: "Guitar", emoji: "üé∏" },
            { name: "Pizza", emoji: "üçï" }, { name: "Cake", emoji: "üéÇ" },
            { name: "Ice Cream", emoji: "üç¶" }, { name: "Coffee", emoji: "‚òï" },
            { name: "Heart", emoji: "‚ù§Ô∏è" }, { name: "Diamond", emoji: "üíé" },
            { name: "Crown", emoji: "üëë" }, { name: "Key", emoji: "üîë" },
            { name: "Gift", emoji: "üéÅ" }, { name: "Balloon", emoji: "üéà" },
            { name: "Fire", emoji: "üî•" }, { name: "Water", emoji: "üíß" },
            { name: "Lightning", emoji: "‚ö°" }, { name: "Snowflake", emoji: "‚ùÑÔ∏è" }
        ];

        const objectDataGujarati = [
            { name: "‡™∏‡™´‡™∞‡™ú‡™®", emoji: "üçé" }, { name: "‡™ï‡´á‡™≥‡´Å‡™Ç", emoji: "üçå" },
            { name: "‡™∏‡™Ç‡™§‡™∞‡´Å‡™Ç", emoji: "üçä" }, { name: "‡™¶‡´ç‡™∞‡™æ‡™ï‡´ç‡™∑", emoji: "üçá" },
            { name: "‡™§‡™∞‡™¨‡´Ç‡™ö", emoji: "üçâ" }, { name: "‡™∏‡´ç‡™ü‡´ç‡™∞‡´ã‡™¨‡´á‡™∞‡´Ä", emoji: "üçì" },
            { name: "‡™≤‡´Ä‡™Ç‡™¨‡´Å", emoji: "üçã" }, { name: "‡™ï‡´á‡™∞‡´Ä", emoji: "ü•≠" },
            { name: "‡™¨‡™ø‡™≤‡™æ‡™°‡´Ä", emoji: "üê±" }, { name: "‡™ï‡´Ç‡™§‡™∞‡´ã", emoji: "üê∂" },
            { name: "‡™∏‡™ø‡™Ç‡™π", emoji: "ü¶Å" }, { name: "‡™µ‡™æ‡™ò", emoji: "üêÖ" },
            { name: "‡™π‡™æ‡™•‡´Ä", emoji: "üêò" }, { name: "‡™∏‡™∏‡™≤‡´Å‡™Ç", emoji: "üê∞" },
            { name: "‡™∞‡´Ä‡™Ç‡™õ", emoji: "üêª" }, { name: "‡™∂‡™ø‡™Ø‡™æ‡™≥", emoji: "ü¶ä" },
            { name: "‡™µ‡´É‡™ï‡´ç‡™∑", emoji: "üå≥" }, { name: "‡™´‡´Ç‡™≤", emoji: "üå∏" },
            { name: "‡™∏‡´Ç‡™∞‡´ç‡™Ø", emoji: "‚òÄÔ∏è" }, { name: "‡™ö‡™Ç‡™¶‡´ç‡™∞", emoji: "üåô" },
            { name: "‡™§‡™æ‡™∞‡´ã", emoji: "‚≠ê" }, { name: "‡™µ‡™æ‡™¶‡™≥", emoji: "‚òÅÔ∏è" },
            { name: "‡™Æ‡´á‡™ò‡™ß‡™®‡´Å‡™∑", emoji: "üåà" }, { name: "‡™™‡™∞‡´ç‡™µ‡™§", emoji: "‚õ∞Ô∏è" },
            { name: "‡™ò‡™∞", emoji: "üè†" }, { name: "‡™ï‡™æ‡™∞", emoji: "üöó" },
            { name: "‡™µ‡™ø‡™Æ‡™æ‡™®", emoji: "‚úàÔ∏è" }, { name: "‡™µ‡™π‡™æ‡™£", emoji: "üö¢" },
            { name: "‡™™‡´Å‡™∏‡´ç‡™§‡™ï", emoji: "üìö" }, { name: "‡™ï‡™≤‡™Æ", emoji: "‚úèÔ∏è" },
            { name: "‡™´‡´ã‡™®", emoji: "üì±" }, { name: "‡™ï‡™Æ‡´ç‡™™‡´ç‡™Ø‡´Å‡™ü‡™∞", emoji: "üíª" },
            { name: "‡™ò‡™°‡™ø‡™Ø‡™æ‡™≥", emoji: "‚åö" }, { name: "‡™ï‡´á‡™Æ‡´á‡™∞‡™æ", emoji: "üì∑" },
            { name: "‡™¨‡´ã‡™≤", emoji: "‚öΩ" }, { name: "‡™ó‡™ø‡™ü‡™æ‡™∞", emoji: "üé∏" },
            { name: "‡™™‡™ø‡™ù‡™æ", emoji: "üçï" }, { name: "‡™ï‡´á‡™ï", emoji: "üéÇ" },
            { name: "‡™Ü‡™à‡™∏‡™ï‡´ç‡™∞‡´Ä‡™Æ", emoji: "üç¶" }, { name: "‡™ï‡´ã‡™´‡´Ä", emoji: "‚òï" },
            { name: "‡™π‡´É‡™¶‡™Ø", emoji: "‚ù§Ô∏è" }, { name: "‡™π‡´Ä‡™∞‡´ã", emoji: "üíé" },
            { name: "‡™§‡™æ‡™ú", emoji: "üëë" }, { name: "‡™ö‡™æ‡™µ‡´Ä", emoji: "üîë" },
            { name: "‡™≠‡´á‡™ü", emoji: "üéÅ" }, { name: "‡™´‡´Å‡™ó‡´ç‡™ó‡´ã", emoji: "üéà" },
            { name: "‡™Ü‡™ó", emoji: "üî•" }, { name: "‡™™‡™æ‡™£‡´Ä", emoji: "üíß" },
            { name: "‡™µ‡´Ä‡™ú‡™≥‡´Ä", emoji: "‚ö°" }, { name: "‡™¨‡™∞‡™´", emoji: "‚ùÑÔ∏è" }
        ];

        // Enhanced Game State Management
        const gameState = {
            currentScreen: 'setup-screen',
            players: [],
            currentPlayerIndex: 0,
            cards: [],
            flippedCards: [],
            matchedPairs: 0,
            totalPairs: 0,
            gameStartTime: 0,
            totalGameTime: 0,
            gameTimer: null,
            soundEnabled: true,
            gamePaused: false,
            language: 'en-US',
            boardSize: 16,
            isProcessingMatch: false,
            currentScore: 0,
            currentStreak: 0,
            bonusPoints: 0,
            hintsRemaining: 3,
            consecutiveMatches: 0,
            perfectGame: true
        };

        // Available TTS voices for caching
        let availableVoices = [];

        // Load available voices
        function loadVoices() {
            availableVoices = speechSynthesis.getVoices();
        }

        // Utility function to shuffle array
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Utility function to randomly select items from array
        function getRandomObjects(objectArray, count) {
            const shuffled = shuffleArray(objectArray);
            return shuffled.slice(0, Math.min(count, shuffled.length));
        }

        // Enhanced Text-to-Speech function with language support
        function speakText(text) {
            if (!gameState.soundEnabled || !window.speechSynthesis) return;
            
            // Cancel any ongoing speech
            speechSynthesis.cancel();
            
            const utterance = new SpeechSynthesisUtterance(text);
            
            // Set language based on game language
            const targetLang = gameState.language === 'gu-IN' ? 'gu-IN' : 'en-US';
            utterance.lang = targetLang;
            
            // Try to find appropriate voice for the language
            const voices = availableVoices.length ? availableVoices : speechSynthesis.getVoices();
            
            // Look for exact language match first
            let selectedVoice = voices.find(voice => voice.lang === targetLang);
            
            // Fallback to language code match (e.g., 'gu' for Gujarati, 'en' for English)
            if (!selectedVoice) {
                const langCode = targetLang.split('-')[0];
                selectedVoice = voices.find(voice => voice.lang.startsWith(langCode));
            }
            
            // Fallback to default system voice
            if (!selectedVoice && voices.length > 0) {
                selectedVoice = voices[0];
            }
            
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            }
            
            // Speech settings
            utterance.volume = 0.7;
            utterance.rate = gameState.language === 'gu-IN' ? 0.7 : 0.8;
            utterance.pitch = 1;
            
            // Error handling
            utterance.onerror = function(event) {
                console.warn('Speech synthesis error:', event.error);
            };
            
            speechSynthesis.speak(utterance);
        }

        // Page Navigation
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
            gameState.currentScreen = screenId;
        }

        // Player Input Management
        function generatePlayerInputs() {
            const numPlayers = parseInt(document.getElementById('num-players').value);
            const container = document.getElementById('player-name-inputs');
            container.innerHTML = '';

            for (let i = 1; i <= numPlayers; i++) {
                const playerRow = document.createElement('div');
                playerRow.className = 'player-name-row';
                playerRow.innerHTML = `
                    <div class="player-indicator">${i}</div>
                    <input type="text" id="player-${i}-name" placeholder="Enter Player ${i} name" required>
                `;
                container.appendChild(playerRow);
            }
        }

        // Game Initialization
        function startGame() {
            const numPlayers = parseInt(document.getElementById('num-players').value);
            const boardSize = parseInt(document.getElementById('board-size').value);
            const language = document.getElementById('language-select').value;

            // Validate board size
            if (boardSize < 4 || boardSize > 200 || boardSize % 2 !== 0) {
                // Using a custom modal or message box instead of alert()
                document.getElementById('status-display').textContent = 'Board size must be between 4-200 and an even number!';
                setTimeout(() => updateStatus('Click cards to find matching pairs!'), 3000);
                return;
            }

            // Collect player names and initialize players
            gameState.players = [];
            for (let i = 1; i <= numPlayers; i++) {
                const nameInput = document.getElementById(`player-${i}-name`);
                const playerName = nameInput.value.trim() || `Player ${i}`;
                gameState.players.push({
                    name: playerName,
                    matches: 0,
                    score: 0,
                    gameTime: 0,
                    isWinner: false
                });
            }

            // Initialize game settings
            gameState.language = language;
            gameState.boardSize = boardSize;
            gameState.totalPairs = boardSize / 2;
            gameState.matchedPairs = 0;
            gameState.currentPlayerIndex = 0;
            gameState.flippedCards = [];
            gameState.gameStartTime = Date.now();
            gameState.totalGameTime = 0;
            gameState.gamePaused = false;
            gameState.isProcessingMatch = false;
            gameState.currentScore = 0;
            gameState.currentStreak = 0;
            gameState.bonusPoints = 0;
            gameState.hintsRemaining = 3;
            gameState.consecutiveMatches = 0;
            gameState.perfectGame = true;

            // Setup game components
            createGameBoard();
            setupPlayerDisplay();
            updateProgress();
            updateScoreBoard();
            startGameTimer();
            showScreen('game-screen');
            document.getElementById('hint-btn').style.display = 'block';
            updateStatus(`${gameState.players[gameState.currentPlayerIndex].name}'s turn!`);
        }

        function createGameBoard() {
            const gameGrid = document.getElementById('game-grid');
            gameGrid.innerHTML = '';

            // Calculate optimal grid layout - Removed fixed column logic for fluid responsiveness
            const totalCards = gameState.boardSize;

            // Get object data based on language
            const objectData = gameState.language === 'gu-IN' ? objectDataGujarati : objectDataEnglish;
            
            // Random object selection
            const selectedObjects = getRandomObjects(objectData, gameState.totalPairs);
            const cardPairs = [...selectedObjects, ...selectedObjects];

            // Shuffle the cards
            const shuffledCards = shuffleArray(cardPairs);

            // Create card elements and add to game state
            gameState.cards = shuffledCards.map((obj, index) => {
                const cardContainer = document.createElement('div');
                cardContainer.className = 'card-container';

                const card = document.createElement('div');
                card.className = 'card';
                card.dataset.index = index;
                card.dataset.name = obj.name;
                card.dataset.emoji = obj.emoji;

                // Card back face (plain design without ? mark)
                const cardBack = document.createElement('div');
                cardBack.className = 'card-face card-back';

                // Card front face
                const cardFront = document.createElement('div');
                cardFront.className = 'card-face card-front';
                cardFront.innerHTML = `
                    <div class="card-emoji">${obj.emoji}</div>
                    <div class="card-name">${obj.name}</div>
                `;

                card.appendChild(cardBack);
                card.appendChild(cardFront);
                cardContainer.appendChild(card);

                card.addEventListener('click', () => handleCardClick(index));
                gameGrid.appendChild(cardContainer);
                
                return {
                    name: obj.name,
                    emoji: obj.emoji,
                    element: card,
                    container: cardContainer,
                    flipped: false,
                    matched: false
                };
            });
        }

        function setupPlayerDisplay() {
            const playerInfoBar = document.getElementById('player-info-bar');
            playerInfoBar.innerHTML = '';

            gameState.players.forEach((player, index) => {
                const playerBox = document.createElement('div');
                playerBox.className = 'player-box';
                if (index === gameState.currentPlayerIndex) {
                    playerBox.classList.add('active');
                }

                playerBox.innerHTML = `
                    <div class="player-name">${player.name}</div>
                    <div class="player-stats">
                        <span>Matches: <strong id="player-${index}-matches">0</strong></span>
                        <span>Score: <strong id="player-${index}-score">0</strong></span>
                    </div>
                `;

                playerInfoBar.appendChild(playerBox);
            });
        }

        function updateProgress() {
            const progressText = document.getElementById('progress-text');
            const progressFill = document.getElementById('progress-fill');
            
            const percentage = gameState.totalPairs > 0 ? (gameState.matchedPairs / gameState.totalPairs) * 100 : 0;
            
            progressText.textContent = `${gameState.matchedPairs} of ${gameState.totalPairs} pairs matched`;
            progressFill.style.width = `${percentage}%`;
        }

        function updateScoreBoard() {
            document.getElementById('current-score').textContent = gameState.currentScore;
            document.getElementById('current-streak').textContent = gameState.currentStreak;
            document.getElementById('bonus-points').textContent = gameState.bonusPoints;
        }

        // Enhanced Game Logic with Scoring System
        function handleCardClick(index) {
            if (gameState.gamePaused || gameState.isProcessingMatch) return;
            
            const card = gameState.cards[index];
            if (card.flipped || card.matched || gameState.flippedCards.length >= 2) return;

            // Flip the card
            card.flipped = true;
            card.element.classList.add('flipped');
            gameState.flippedCards.push(index);

            playGameSound('flip');
            speakText(card.name);

            // Check for match when two cards are flipped
            if (gameState.flippedCards.length === 2) {
                gameState.isProcessingMatch = true;
                setTimeout(processMatchCheck, 800);
            }
        }

        function processMatchCheck() {
            const [index1, index2] = gameState.flippedCards;
            const card1 = gameState.cards[index1];
            const card2 = gameState.cards[index2];

            if (card1.emoji === card2.emoji) {
                // Match found!
                card1.matched = true;
                card2.matched = true;
                card1.element.classList.add('matched');
                card2.element.classList.add('matched');

                // Calculate score with bonuses
                let baseScore = 100;
                gameState.currentStreak++;
                gameState.consecutiveMatches++;
                
                // Streak bonus
                if (gameState.currentStreak >= 3) {
                    gameState.bonusPoints += gameState.currentStreak * 50;
                    showStreakIndicator();
                }
                
                // Time bonus (faster = more points)
                const timeElapsed = Math.floor((Date.now() - gameState.gameStartTime) / 1000);
                const timeBonus = Math.max(0, 300 - timeElapsed);
                
                const totalScore = baseScore + (gameState.currentStreak * 25) + timeBonus;
                gameState.currentScore += totalScore;
                gameState.players[gameState.currentPlayerIndex].matches++;
                gameState.players[gameState.currentPlayerIndex].score += totalScore;
                gameState.matchedPairs++;

                updatePlayerDisplay();
                updateProgress();
                updateScoreBoard();
                playGameSound('match');

                // Check for achievements
                checkAchievements();

                // Check if game is complete
                if (gameState.matchedPairs === gameState.totalPairs) {
                    setTimeout(() => {
                        endGame();
                        createCelebration();
                    }, 1000);
                }
            } else {
                // No match - reset streak and show shake animation
                gameState.currentStreak = 0;
                gameState.perfectGame = false;
                updateScoreBoard();
                
                card1.element.classList.add('shake');
                card2.element.classList.add('shake');
                
                setTimeout(() => {
                    card1.flipped = false;
                    card2.flipped = false;
                    card1.element.classList.remove('flipped', 'shake');
                    card2.element.classList.remove('flipped', 'shake');
                }, 400);

                playGameSound('miss');
                switchToNextPlayer();
            }

            gameState.flippedCards = [];
            gameState.isProcessingMatch = false;
            updateStatus(`${gameState.players[gameState.currentPlayerIndex].name}'s turn!`);
        }

        function showStreakIndicator() {
            const indicator = document.getElementById('streak-indicator');
            indicator.textContent = `üî• Streak x${gameState.currentStreak}!`;
            indicator.classList.add('show');
            
            setTimeout(() => {
                indicator.classList.remove('show');
            }, 2000);
        }

        function checkAchievements() {
            if (gameState.currentStreak === 5) {
                showAchievement('üî• Hot Streak! 5 consecutive matches!');
            } else if (gameState.currentStreak === 10) {
                showAchievement('üåü Memory Master! 10 consecutive matches!');
            } else if (gameState.matchedPairs === Math.floor(gameState.totalPairs / 2)) {
                showAchievement('‚ö° Halfway Champion!');
            }
        }

        function showAchievement(text) {
            const notification = document.getElementById('achievement-notification');
            document.getElementById('achievement-text').textContent = text;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        function switchToNextPlayer() {
            // Remove active class from current player
            document.querySelector('.player-box.active')?.classList.remove('active');

            // Move to next player
            gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;

            // Add active class to new current player
            const playerBoxes = document.querySelectorAll('.player-box');
            playerBoxes[gameState.currentPlayerIndex].classList.add('active');
        }

        function updatePlayerDisplay() {
            gameState.players.forEach((player, index) => {
                const matchesElement = document.getElementById(`player-${index}-matches`);
                const scoreElement = document.getElementById(`player-${index}-score`);
                if (matchesElement) {
                    matchesElement.textContent = player.matches;
                }
                if (scoreElement) {
                    scoreElement.textContent = player.score;
                }
            });
        }

        function updateStatus(message) {
            document.getElementById('status-display').textContent = message;
        }

        // Hint System
        function useHint() {
            if (gameState.hintsRemaining <= 0 || gameState.isProcessingMatch) return;
            
            gameState.hintsRemaining--;
            document.getElementById('hint-btn').textContent = `üí° Hint (${gameState.hintsRemaining})`;
            
            if (gameState.hintsRemaining <= 0) {
                document.getElementById('hint-btn').disabled = true;
            }

            // Find an unmatched pair and briefly show them
            const unmatchedCards = gameState.cards.filter(card => !card.matched && !card.flipped);
            if (unmatchedCards.length >= 2) {
                // Find a matching pair
                for (let i = 0; i < unmatchedCards.length; i++) {
                    for (let j = i + 1; j < unmatchedCards.length; j++) {
                        if (unmatchedCards[i].emoji === unmatchedCards[j].emoji) {
                            // Briefly flip these cards
                            const card1 = unmatchedCards[i];
                            const card2 = unmatchedCards[j];
                            
                            card1.element.classList.add('flipped');
                            card2.element.classList.add('flipped');
                            
                            setTimeout(() => {
                                card1.element.classList.remove('flipped');
                                card2.element.classList.remove('flipped');
                            }, 1500);
                            
                            playGameSound('match');
                            return;
                        }
                    }
                }
            }
        }

        // Create enhanced celebration effect
        function createCelebration() {
            const celebrationContainer = document.getElementById('celebration');
            celebrationContainer.classList.remove('hidden');
            
            // Create colorful confetti
            const colors = ['#00d4ff', '#22d3ee', '#ffd700', '#fbbf24', '#ef4444', '#22c55e'];
            for (let i = 0; i < 80; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.animationDelay = Math.random() * 4 + 's';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                celebrationContainer.appendChild(confetti);
            }

            // Remove celebration after 5 seconds
            setTimeout(() => {
                celebrationContainer.classList.add('hidden');
                celebrationContainer.innerHTML = '';
            }, 5000);
        }

        // Timer Functions
        function startGameTimer() {
            gameState.gameTimer = setInterval(updateGameTimer, 1000);
        }

        function updateGameTimer() {
            if (gameState.gamePaused) return;

            const elapsed = Math.floor((Date.now() - gameState.gameStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;

            document.getElementById('game-timer').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function stopGameTimer() {
            if (gameState.gameTimer) {
                clearInterval(gameState.gameTimer);
                gameState.gameTimer = null;
            }
        }

        // Game End Logic
        function endGame() {
            stopGameTimer();
            gameState.totalGameTime = Math.floor((Date.now() - gameState.gameStartTime) / 1000);

            // Perfect game bonus
            if (gameState.perfectGame) {
                gameState.bonusPoints += 1000;
                showAchievement('üéØ Perfect Game! No mistakes bonus!');
            }

            // Speed bonus
            if (gameState.totalGameTime < gameState.totalPairs * 10) {
                gameState.bonusPoints += 500;
                showAchievement('‚ö° Speed Demon! Time bonus!');
            }

            // Determine winner by highest score
            const maxScore = Math.max(...gameState.players.map(p => p.score));
            gameState.players.forEach(player => {
                player.gameTime = gameState.totalGameTime;
                player.isWinner = player.score === maxScore;
            });

            // Save game results to leaderboard
            saveToLeaderboard();

            // Display results and show results page
            displayGameResults();
            playGameSound('win');
            showScreen('results-screen');
        }

        function displayGameResults() {
            const winners = gameState.players.filter(p => p.isWinner);
            const winnerText = document.getElementById('winner-text');
            const finalResults = document.getElementById('final-results');

            // Display winner announcement
            if (winners.length === 1) {
                winnerText.textContent = `üèÜ ${winners[0].name} Wins the Championship! üèÜ`;
            } else {
                winnerText.textContent = `üéâ Championship Tie! üéâ`;
            }

            // Display detailed results for each player
            finalResults.innerHTML = '';
            gameState.players.sort((a, b) => b.score - a.score).forEach((player, index) => {
                const resultCard = document.createElement('div');
                resultCard.className = 'player-final-result';
                if (player.isWinner) {
                    resultCard.classList.add('winner-result');
                }

                const minutes = Math.floor(player.gameTime / 60);
                const seconds = player.gameTime % 60;
                const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                const rankIcon = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : 'üèÖ';

                resultCard.innerHTML = `
                    <div class="final-player-name">
                        ${rankIcon} ${player.name} ${player.isWinner ? 'üëë' : ''}
                    </div>
                    <div class="final-stats">
                        <div class="final-stat">
                            <div class="final-stat-value">${player.score}</div>
                            <div class="final-stat-label">Total Score</div>
                        </div>
                        <div class="final-stat">
                            <div class="final-stat-value">${player.matches}</div>
                            <div class="final-stat-label">Matches</div>
                        </div>
                        <div class="final-stat">
                            <div class="final-stat-value">${timeString}</div>
                            <div class="final-stat-label">Time</div>
                        </div>
                        <div class="final-stat">
                            <div class="final-stat-value">${((player.matches / gameState.totalPairs) * 100).toFixed(0)}%</div>
                            <div class="final-stat-label">Success Rate</div>
                        </div>
                    </div>
                `;

                finalResults.appendChild(resultCard);
            });
        }

        // Game Control Functions
        function playAgain() {
            // Reset game state but keep players
            gameState.matchedPairs = 0;
            gameState.currentPlayerIndex = 0;
            gameState.flippedCards = [];
            gameState.gameStartTime = Date.now();
            gameState.totalGameTime = 0;
            gameState.gamePaused = false;
            gameState.isProcessingMatch = false;
            gameState.currentScore = 0;
            gameState.currentStreak = 0;
            gameState.bonusPoints = 0;
            gameState.hintsRemaining = 3;
            gameState.consecutiveMatches = 0;
            gameState.perfectGame = true;

            // Reset player stats
            gameState.players.forEach(player => {
                player.matches = 0;
                player.score = 0;
                player.gameTime = 0;
                player.isWinner = false;
            });

            // Recreate game board with NEW random objects and restart
            createGameBoard();
            setupPlayerDisplay();
            updateProgress();
            updateScoreBoard();
            startGameTimer();
            showScreen('game-screen');
            document.getElementById('hint-btn').style.display = 'block';
            document.getElementById('hint-btn').disabled = false;
            document.getElementById('hint-btn').textContent = 'üí° Hint (3)';
            updateStatus(`${gameState.players[gameState.currentPlayerIndex].name}'s turn!`);
        }

        function restartGame() {
            // Return to setup page for new game configuration
            stopGameTimer();
            gameState.players = [];
            document.getElementById('hint-btn').style.display = 'none';
            showScreen('setup-screen');
        }

        function pauseGame() {
            gameState.gamePaused = !gameState.gamePaused;
            const pauseBtn = event.target;

            if (gameState.gamePaused) {
                pauseBtn.textContent = '‚ñ∂Ô∏è Resume';
                pauseBtn.classList.add('secondary');
            } else {
                pauseBtn.textContent = '‚è∏Ô∏è Pause';
                pauseBtn.classList.remove('secondary');
            }
        }

        function quitGame() {
            // Using a custom modal-like approach instead of confirm()
            const message = 'Are you sure you want to quit to main menu? Current game progress will be lost.';
            if (confirm(message)) {
                restartGame();
            }
        }

        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            const soundBtn = document.getElementById('sound-btn');
            soundBtn.textContent = gameState.soundEnabled ? 'üîä Sound On' : 'üîá Sound Off';
        }

        // Enhanced Leaderboard Functions with Score Tracking
        function saveToLeaderboard() {
            let leaderboard = JSON.parse(localStorage.getItem('memoryGameLeaderboard') || '{}');

            gameState.players.forEach(player => {
                if (!leaderboard[player.name]) {
                    leaderboard[player.name] = {
                        gamesPlayed: 0,
                        gamesWon: 0,
                        gamesLost: 0,
                        bestTime: null,
                        totalTime: 0,
                        totalPairs: 0,
                        totalScore: 0,
                        highScore: 0,
                        lastPlayed: null
                    };
                }

                const playerStats = leaderboard[player.name];
                playerStats.gamesPlayed++;
                playerStats.totalTime += player.gameTime;
                playerStats.totalPairs += player.matches;
                playerStats.totalScore += player.score;
                playerStats.lastPlayed = new Date().toISOString();

                if (player.score > playerStats.highScore) {
                    playerStats.highScore = player.score;
                }

                if (player.isWinner) {
                    playerStats.gamesWon++;
                } else {
                    playerStats.gamesLost++;
                }

                if (playerStats.bestTime === null || player.gameTime < playerStats.bestTime) {
                    playerStats.bestTime = player.gameTime;
                }
            });

            localStorage.setItem('memoryGameLeaderboard', JSON.stringify(leaderboard));
        }

        function showLeaderboard() {
            const leaderboard = JSON.parse(localStorage.getItem('memoryGameLeaderboard') || '{}');
            const leaderboardBody = document.getElementById('leaderboard-body');
            const emptyLeaderboard = document.getElementById('empty-leaderboard');
            const leaderboardTable = document.getElementById('leaderboard-table');
            const statsContainer = document.getElementById('leaderboard-stats-summary');

            // Clear previous content
            leaderboardBody.innerHTML = '';
            statsContainer.innerHTML = '';

            if (Object.keys(leaderboard).length === 0) {
                emptyLeaderboard.classList.remove('hidden');
                leaderboardTable.style.display = 'none';
                statsContainer.style.display = 'none';
            } else {
                emptyLeaderboard.classList.add('hidden');
                leaderboardTable.style.display = 'table';
                statsContainer.style.display = 'grid';

                // Calculate overall statistics
                const totalPlayers = Object.keys(leaderboard).length;
                const totalGames = Object.values(leaderboard).reduce((sum, stats) => sum + stats.gamesPlayed, 0);
                const totalPairs = Object.values(leaderboard).reduce((sum, stats) => sum + stats.totalPairs, 0);
                const totalScore = Object.values(leaderboard).reduce((sum, stats) => sum + stats.totalScore, 0);
                const totalTime = Object.values(leaderboard).reduce((sum, stats) => sum + stats.totalTime, 0);

                // Display summary statistics
                const summaryStats = [
                    { label: 'Total Players', value: totalPlayers },
                    { label: 'Total Games', value: totalGames },
                    { label: 'Total Score', value: totalScore.toLocaleString() },
                    { label: 'Total Pairs', value: totalPairs },
                    { label: 'Playing Time', value: formatTime(totalTime) }
                ];

                summaryStats.forEach(stat => {
                    const statCard = document.createElement('div');
                    statCard.className = 'stats-card';
                    statCard.innerHTML = `
                        <div class="stats-card-value">${stat.value}</div>
                        <div class="stats-card-label">${stat.label}</div>
                    `;
                    statsContainer.appendChild(statCard);
                });

                // Sort players by highest score first
                const sortedPlayers = Object.entries(leaderboard)
                    .sort((a, b) => b[1].highScore - a[1].highScore);

                sortedPlayers.forEach(([playerName, stats], index) => {
                    const row = document.createElement('tr');

                    const rankClass = index < 3 ? `rank-${index + 1}` : '';
                    const bestTimeString = stats.bestTime ? formatTime(stats.bestTime) : 'N/A';
                    const totalTimeString = formatTime(stats.totalTime);
                    const avgTime = stats.gamesPlayed > 0 ? Math.floor(stats.totalTime / stats.gamesPlayed) : 0;
                    const avgTimeString = formatTime(avgTime);
                    const winRate = stats.gamesPlayed > 0 ? 
                        Math.round((stats.gamesWon / stats.gamesPlayed) * 100) : 0;
                    const avgPairsPerGame = stats.gamesPlayed > 0 ? 
                        (stats.totalPairs / stats.gamesPlayed).toFixed(1) : '0.0';
                    const avgScorePerGame = stats.gamesPlayed > 0 ? 
                        Math.round(stats.totalScore / stats.gamesPlayed) : 0;
                    const lastPlayedDate = stats.lastPlayed ? 
                        new Date(stats.lastPlayed).toLocaleDateString() : 'N/A';

                    // Color code win rate
                    let winRateClass = 'win-rate-low';
                    if (winRate >= 70) winRateClass = 'win-rate-high';
                    else if (winRate >= 40) winRateClass = 'win-rate-medium';

                    row.innerHTML = `
                        <td><span class="rank-position ${rankClass}">${index + 1}</span></td>
                        <td class="player-name-cell">${playerName}</td>
                        <td style="color: var(--gold-color); font-weight: 700;">${stats.highScore.toLocaleString()}</td>
                        <td>${stats.gamesPlayed}</td>
                        <td>${stats.gamesWon}</td>
                        <td>${stats.gamesLost}</td>
                        <td class="${winRateClass}">${winRate}%</td>
                        <td>${stats.totalPairs}</td>
                        <td>${avgPairsPerGame}</td>
                        <td>${bestTimeString}</td>
                        <td>${totalTimeString}</td>
                        <td>${avgTimeString}</td>
                        <td>${lastPlayedDate}</td>
                    `;

                    leaderboardBody.appendChild(row);
                });
            }

            showScreen('leaderboard-screen');
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function clearLeaderboard() {
            // Using a custom modal-like approach instead of confirm()
            const message = 'Are you sure you want to clear all championship records? This action cannot be undone.';
            if (confirm(message)) {
                localStorage.removeItem('memoryGameLeaderboard');
                showLeaderboard();
            }
        }

        function backFromLeaderboard() {
            // Smart navigation back to appropriate screen
            if (gameState.players.length > 0 && gameState.matchedPairs < gameState.totalPairs) {
                showScreen('game-screen');
            } else if (gameState.players.length > 0 && gameState.matchedPairs === gameState.totalPairs) {
                showScreen('results-screen');
            } else {
                showScreen('setup-screen');
            }
        }

        // Enhanced Sound Effects
        function playGameSound(soundType) {
            if (!gameState.soundEnabled) return;

            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            const soundConfig = {
                flip: { frequency: 880, duration: 180 },
                match: { frequency: 1320, duration: 350 },
                miss: { frequency: 440, duration: 300 },
                win: { frequency: 1760, duration: 800 }
            };

            const config = soundConfig[soundType] || soundConfig.flip;
            oscillator.frequency.value = config.frequency;
            oscillator.type = 'sine';

            gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + config.duration / 1000);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + config.duration / 1000);
        }

        // Initialize Application
        document.addEventListener('DOMContentLoaded', function() {
            generatePlayerInputs();
            
            // Load voices when available
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = loadVoices;
            }
            loadVoices();
        });
    </script>
</body>
</html>
